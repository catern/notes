* prep :noexport:
#+begin_src elisp
(progn
  (setq
    ;; hide equals signs
    org-hide-emphasis-markers t
    text-scale-mode-amount 6
    mode-line-format nil
  )
  (org-mode)
  (org-toggle-inline-images)
  (text-scale-mode 6)
  (blink-cursor-mode -1)
  (visual-line-mode 1)
  ;; so things go into effect
  (set-window-buffer
    (get-buffer-window (current-buffer))
    (current-buffer)))
#+end_src
** unprep
#+begin_src elisp
(progn
  (setq org-hide-emphasis-markers nil)
  (visual-line-mode -1)
  (kill-local-variable 'mode-line-format)
)
#+end_src

* TSS Integration
To test your code, you need to run it
[[./logo.png]]
Slides at http://ts/tssintegration

** Who is this guy?
- Spencer Baugh
- Modern Infrastructure for Trading Systems
  (MITS) [[./mitts.jpg]]
- Two Sigma Securities
  (TSS) [[./hihat.jpg]]

This talk is about:
Integration testing in TSS,
with the "TSS Integration" library
[[./logo.png]]

Outline:
1. Brief history of TSS Integration
2. Philosophical discussion of testing
3. Example of a TSS Integration test
4. Closing remarks and questions

If something isn't making sense, ask!

Let's begin!

** Brief history
TSS Integration is:
- a Python library
- Python module name: "integration"
- monorepo path: ts/tss/integration
- Slack channel: #x-tss-integration
[[./logo.png]]

- Used by TSS and TSI
- Maintained collectively by users
- Project started by MITS in TSS in 2017
- We chose Python for wide use
  [[./python.png]]

Scale:
- ~100 different services, across ~10 teams
- ~600 tests
- Used in production for 6 services
- Always growing!

~80000 lines migrated to ~4000 lines:
[[./plot.png]]

Improves mainly as a side effect of:
- Cross team projects;
  mostly add support for new services
  [[./wide.jpg]]
- Single team projects;
  mostly improve existing service support
  [[./tall.jpg]]

But what does it actually do?

** Philosophical discussion

First off:

- TSS Integration is not a testing library
- Its purpose is not testing
- It is not even really testing-related

TSS Integration provides
*the ability to run the trading system*

(See http://catern.com/run.html)

I'll explain that a little more.

Two Sigma systems contain:
- Many different services
- Many different environments
- Many different configurations

[[./mud.png]]

*The ability to run the trading system*

TSS Integration:
- Runs services
- Connects them together
- In arbitrary configurations

[[./notmud.png]]

Diagram generated by tss/integration
from one configuration:
[[./diagram.png]]

*The ability to run the trading system*
for any purpose.

As of today:
| Purpose     | Uses TSS Integration? |
|-------------+-----------------------|
| Development | Yes                   |
| Testing     | Yes                   |
| Profiling   | Yes                   |
| Production  | Several services      |

*The ability to run the trading system*
anywhere.

There are no external service dependencies,
so we can run on:
- Core
- Colo
- COIN
- A single homeserver
- The pre-push test farm
  (we use this heavily!)

*The ability to run the trading system*
makes testing much easier.

Here's one explanation:

- Everything makes assumptions, good or bad
- Violated assumptions cause failures
- More stuff running with no failures,
  means more confidence things are working
- This is why testing in prod is tempting!

(See http://catern.com/usertests.html)

So forget about testing for a moment.

Our goal in this section:
*The ability to run the trading system*
in a flexible, robust, portable way.

So how do we run the system?
It's non-trivial.

There's many different kinds of services.

- Languages: C++, C, Java, Python
- Configs: CSVs, properties, YAML, env vars
- Protocols: Protocolgen, Protobuf, JSON
- Transport: UDP, TCP, mqueue, iqueue
- And more!

Our solution has to handle all this.

Plus we have all the normal problems!

- service discovery,
- distributed execution,
- process management,
- artifact deployment,
- etc...

And we need to stay portable,
and avoid external service dependencies.

Again, we run in:

- Core
- Colo
- COIN
- A single homeserver
- The pre-push test farm

So Kubernetes, etc, won't work.

So what do we do?

It's not so bad actually.
We can solve this with... a type system.

(See http://catern.com/progsys.html)

A type system!

A basic one, like C++/Java have

No fancy stuff

[[./turnstile.png]]

Quick overview of Python type annotations:
#+begin_src python
var: Foo = make_foo()

def f(arg: Foo) -> ReturnType: ...
#+end_src

About the same as Java or C++;
for more info, see
https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html

A basic example problem:

Service A connects to services B and C.
[[./example1.png]]

Immediate consequences:
- B and C need to start before A
- A needs to know the URLs of B and C

A problem of dependency injection...

[[file:tweet.png]]

*** Service dependencies, with functions
#+begin_src python
def start_a(b: B, c: C) -> A:
    "Start an instance of the A service"
    ...
    start_process([
      "/bin/a",
      "--b-url", b.url,
      "--c-url", c.url,
      ...
    ])
    ...
    return A(...)
#+end_src
The =start_a= function:
- takes values of types =B= and =C=
- returns a value of type =A=
- Internally, starts up service A,
  and configures A with the URLs

Want to start service A?
You need instances of =B= and =C= first,
from =start_b= and =start_c=!

TSS Integration, for each service:
- Defines a class A,
  exposing the URL/path/etc of the service
- Defines a function to start the service,
  which returns A,
  and takes dependencies as arguments

*** Track complex configs with types
Service D:
- Speaks either HTTP1 or HTTP2,
  but not both
Service E:
- Depends on D
- Requires that D speak HTTP2
[[./example2.png]]

#+begin_src python
def start_e(d: D[HTTP2Url]) -> E:
    ...
      "--d-url", d.url, # an HTTP2Url
    ...
    return E(...)

def main(d: D[HTTP1Url]) -> E:
    return start_e(d) # type error!
#+end_src

The type argument to the =D= class
specifies the type of =d.url=.
(Like Java generics or C++ templates)

A Two Sigma example:
HFMD tickerplant clients can publish over
- msgbox
- mqueue
- jtmqueue
[[./tickerplant.png]]

*** Make different envs with different args
Service F:
- Can run with or without service G
- Behaves differently in each case
Service G:
- A normal service
[[./example3.png]]

#+begin_src python
def start_f(g: Optional[G]) -> F:
    ...
    if g:
       ... "--g-url", g.url ...
    else:
       pass
    ...

def env_one() -> None:
    g = ...
    f = start_f(g)
    ...

def env_two() -> None:
    f = start_f(None)
    ...
#+end_src

We can use =env_one= or =env_two=,
each where appropriate.
(See http://catern.com/config.html)

In TSS Integration,
- production/tests/benchmarking
- TSS/TSI
- equities/futures/options
All build different environments,
with the same functions and types

*** Interact using the REPL/debugger
A minor nice feature...

Useful for:
- Debugging a system
- Manipulating it in an ad-hoc way

#+begin_src python
>> i = start_i(...)
<I object at 0x7fb3a45a4290>
>> j = start_j(i, ...)
<J object at 0x7fb3a45a4490>
>> j.url
"https://example.com"
#+end_src

So that's how TSS Integration provides
*the ability to run the trading system*.

** In-depth example of a test with TSS Integration

TPS: Two sigma Position Service.

- Receives orders from the world over TCP
- Validates and maybe rejects those orders
- Updates the =posdelta= service with fills
- Stores data in a SQLite database
[[./tps.png]]

Why TPS?

- TPS has few dependencies
- TSS Integration runs TPS in production

Our goal in this example:
Put the theory from earlier into practice

Pretend:
- There are no other tests for TPS
- We already have TPS types and functions
- Now let's set up an environment with TPS!

We start with a =TrioTestCase=;
an async-enabled =unittest.TestCase=,
but otherwise standard Python.

There's nothing async in this example;
just ignore the =async= and =await= keywords
#+begin_src python
class TestTPS(TrioTestCase):
  async def asyncSetUp(self) -> None:
    # Start up TPS, and its deps
    self.tps = await start_tps(...)

  async def test(self) -> None:
    # The actual test!
    self.assertTrue("Do test stuff")
#+end_src

#+begin_src python
async def start_tps(
  nursery: trio.Nursery,
  thread: rsyscall.Thread,
  listening_sock: FileDescriptor,
  database: integration.tps.Database,
  posdelta: Posdelta,
) -> TPS:
  ...
#+end_src
[[./tps.png]]

#+begin_src python
  nursery: trio.Nursery,
#+end_src

- Start up functions in the background,
  and detect if they fail
- =self.nursery= is a =trio.Nursery=
  which turns any background failure
  into a test failure

#+begin_src python
  async def asyncSetUp(self) -> None:
    self.tps = await start_tps(
      self.nursery,
      ...,
    )
#+end_src

For more info on trio see:
https://trio.readthedocs.io/en/stable/tutorial.html

#+begin_src python
  thread: rsyscall.Thread,
#+end_src

- Lets us run things on a remote host
- We'll use =local_thread= to run locally

#+begin_src python
from rsyscall import local_thread

  async def asyncSetUp(self) -> None:
    self.thread = local_thread
    self.tps = await start_tps(
      ...,
      self.thread,
      ...,
    )
#+end_src

For more info on rsyscall see:
https://github.com/catern/rsyscall

#+begin_src python
  listening_sock: FileDescriptor,
#+end_src

- The first TPS-specific argument
- Used by TPS to listen for TCP connections
- Standard Unix socket programming
#+begin_src python
    # make a TCP socket
    sock = await self.thread.socket(
      AF.INET, SOCK.STREAM)
    # bind it to a random port on localhost
    addr = SockaddrIn(0, "127.0.0.1")
    await sock.bind(
      await self.thread.ptr(addr))
    # and start listening
    await sock.listen(1024)
    self.tps = await start_tps(
      ...,
      sock,
      ...,
    )
#+end_src

#+begin_src python
  database: integration.tps.Database,
#+end_src

- Used to store persistent state

#+begin_src python
    # Make a temporary directory
    self.testdir = make_testdir()
    self.tps = await start_tps(
      ...,
      # Initialize it with the TPS schema
      await integration.tps.Database.make(
        # Make it locally with self.thread
        self.thread, self.testdir/"db"),
      ...,
    )
#+end_src

#+begin_src python
  posdelta: Posdelta,
#+end_src
A service sending out position updates

#+begin_src python
async def start_posdelta(
  nursery: trio.Nursery,
  thread: rsyscall.Thread,
  workdir: Path,
) -> Posdelta: ...
#+end_src

#+begin_src python
    self.tps = await start_tps(
      ...,
      await start_posdelta(
        # Same as TPS
        self.nursery, self.thread,
        (self.testdir/"posdelta").mkdir()),
    )
#+end_src

That's everything!

#+begin_src python
class TestTPS(TrioTestCase):
  async def asyncSetUp(self) -> None:
    self.testdir = make_testdir()
    self.thread = local_thread
    sock = await self.thread.socket(
      AF.INET, SOCK.STREAM)
    addr = SockaddrIn(0, "127.0.0.1")
    await sock.bind(
      await self.thread.ptr(addr))
    await sock.listen(1024)
    self.tps = await start_tps(
      self.nursery, self.thread,
      sock,
      await Database.make(
        self.thread, self.testdir/"db"),
      await start_posdelta(
        self.nursery, self.thread,
        (self.testdir/"posdelta").mkdir()),
    )
#+end_src

Now we start the Python client for TPS

#+begin_src python
  async def asyncSetUp(self) -> None:
    self.tps = ...
    self.client =
      await integration.tps.Client.connect(
        self.thread, self.tps.sockaddr)
#+end_src

Just send an order and fill

#+begin_src python
    async def test(self) -> None:
        order = await self.client.new_order(
            'buy', 100,
            self.tps.static_data.instruments[0],
            price=Decimal('50.0'))
        await order.fill(100, Decimal('50.0'))
#+end_src

- This is a complete test
- All the services are checking invariants
- Violations cause exceptions
- For example: If TPS errors or crashes,
  we'll get an exception
- Set up more services for more coverage,
  but the test method stays the same

** Closing remarks and questions

By making it easy to run the system,
we've improved our ability to test.

Areas for future development:
- Support for more services
- Usage by more teams
- More production usage

More significant long-term development:
- Usage outside Trading Engineering
  (Seigniorage project?)

How to get started?

To add your services to TSS Integration,
or to write your own library:

1. Understand your service dependencies;
   this is the hardest step!
2. Write down classes, function signatures
3. Implement them; this is relatively easy!

Would you like to know more?
Or get help starting?
- Now, ask me questions
- Later, join #x-tss-integration and ask
- Look at ts/tss/integration/README.org
  https://gitlab.twosigma.com/main/ts.d/tss.d/integration-git/-/blob/master/README.org

Hopefully this talk has shown you
the importance of running your system.

Slides at http://ts/tssintegration
[[./logo.png]]
- type-safe composition and configuration of services, without limits
- safe for, and used in, prod
- runs anywhere, including pre-push, homeservers, or colo
- requires no special privileges
- doesn't depend on any outside services
- can be used interactively from a REPL or debugger
- optimized process startup to avoid the usual monorepo high per-process startup delays
- distributed execution, can run across multiple hosts
- arbitrary universes, can run services from different universes together
- monitors processes at all times so that any process exits will be detected
- processes can be pinned to CPUs and customized in many other ways
- doesn't leave stray orphan processes behind
- easy to clean up after, everything goes in a single directory

Example: trio and rsyscall and remote execution
#+begin_src python
async def start_fooserv(
    nursery: trio.Nursery,
    thread: rsyscall.Thread,
    workdir: Path,
) -> Fooserv:
    command = ts_fooserv.get_c_binary("fooserv").args(
        "--verbose", "--do-stuff-fast",
    )
    child_thread = await thread.clone()
    await child_thread.chdir(workdir)
    child_process = await child_thread.exec(command)
    nursery.start_soon(child_process.check)
    return Fooserv()
#+end_src

