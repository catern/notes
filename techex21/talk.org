* prep
#+begin_src elisp
(progn
  (setq text-scale-mode-amount 5)
  (text-scale-mode 5)
  (blink-cursor-mode -1)
  (setq left-margin-width 0)
  ;; so left-margin-width goes into effect
  (set-window-buffer
    (get-buffer-window (current-buffer))
    (current-buffer)))
#+end_src

* TSS Integration talk
[[./logo.png]]

** Who is this guy?
- Spencer Baugh
- Modern Infrastructure for Trading Systems (MITS) [[./mitts.jpg]]
- Two Sigma Securities (TSS) [[./hihat.jpg]]

Talk is about:
Testing in TSS with the "TSS Integration" library
[[./logo.png]]

1. Brief history of TSS Integration
2. Philosophical discussion of testing
3. In-depth example of a test with TSS Integration
4. Closing remarks and questions

If something isn't making sense, please ask!

Let's begin!

** Brief history
TSS Integration is:
- a Python library
- Python module name: "integration"
- monorepo path: ts/tss/integration
- Slack channel: #x-tss-integration
[[./logo.png]]

- Used by TSS and TSI
- Maintained collectively by users
- Originally developed by MITS in TSS in 2018
- We chose Python so that it could be widely used

Scale:
- ~100 different services, across ~10 teams.
- ~600 tests
- Used in production for 6 services
- Always growing!

Improves mainly in two ways:
- A cross-team change is tested with TSS Integration,
  which expands to cover more services.
- An individual team wants to write new tests,
  so they improve the existing support for their services.

But what does it actually do?

** Philosophical discussion

First off:

- TSS Integration is not a "testing library"
- Its purpose is not testing
- It is not even really testing-related

TSS Integration provides
*the ability to run the trading system*

(See http://catern.com/run.html)

I'll explain that a little more.

Two Sigma systems contain:
- Many different services
- Many different environments
- Many different configurations

*The ability to run the trading system*

TSS Integration:
- Runs these services
- Connects them together
- In arbitrary user-controlled configurations 

Example diagram generated by tss/integration,
of one possible configuration:
[[./diagram.png]]

*The ability to run the trading system*
for any purpose.

| Purpose     | Runs with TSS Integration? |
|-------------+----------------------------|
| Development | Yes                        |
| Testing     | Yes                        |
| Profiling   | Yes                        |
| Production  | Several services           |

*The ability to run the trading system*
anywhere.

There are zero external service dependencies,
so we can run on:
- Core
- Colo
- COIN
- A single homeserver
- The pre-push test farm (we use this heavily)

*The ability to run the trading system*
makes testing much easier.

Here's one explanation:

- Everything makes assumptions about everything else
- If those assumptions are violated, things fail
- So, to test, just run the system
- The more components you run,
  the more confident you can be if nothing fails
- (This is why testing in prod is so tempting!)

(See http://catern.com/usertests.html)

So forget about testing for a moment.

Our goal right now:
*The ability to run the trading system*
in a flexible, robust, portable way.

So how do we run the system?
It's non-trivial.

There's many different kinds of services.

- Languages: C++, C, Java, Python
- Configuration: CSVs, properties, YAML, env vars
- Protocols: Protocolgen, Protobuf, JSON
- Transports: UDP, TCP, mqueue, iqueue, msgbox
- And more!

Our solution has to handle all this.

Plus we have all the normal problems!

- service discovery,
- distributed execution,
- process management,
- artifact deployment,
- etc...

And we need to stay portable,
and avoid external service dependencies.

Again, we run in:

- Core
- Colo
- COIN
- A single homeserver
- The pre-push test farm

So Kubernetes, etc, won't work.

So what do we do?

It's not so bad actually.
We can solve this with... a type system.

(See http://catern.com/progsys.html)

A type system!

A basic one, like C++/Java/Python already have

No fancy stuff, nothing unusual

Quick overview of Python type annotations:
#+begin_src python
var: Foo = make_foo()

def f(arg: Foo) -> ReturnType: ...
#+end_src

About the same as Java or C++;
for more info, see
https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html

A basic example problem:

Service A connects to services B and C.
[[./example1.png]]

Immediate consequences:
- B and C need to start before A
- A needs to know the URLs of B and C

Basically a problem of dependency injection...


[[file:tweet.png]]

*** Dependencies between services with functions
We can express this with a function!

#+begin_src python
def start_a(b: B, c: C) -> A:
    "Start an instance of the A service"
    ...
    start_process([
      "/bin/a",
      "--b-url", b.url,
      "--c-url", c.url,
      ...
    ])
    ...
    return A(...)
#+end_src

The =start_a= function:
- takes values of types =B= and =C=
- returns a value of type =A=
- Internally, starts up service A,
  configuring A using the function arguments

Want to start service A?
You need instances of =B= and =C= first,
from =start_b= and =start_c=!

TSS Integration, for each service:
- Defines a class A,
  which exposes URLs/paths/etc for connecting to the service
- Defines a function to start the service,
  which returns A,
  and takes dependencies as arguments

*** You can keep track of complex values using types
Service D:
- Speaks either HTTP1 or HTTP2, but not both
Service E:
- Depends on D
- Requires that D speak HTTP2
[[./example2.png]]

#+begin_src python
def start_e(d: D[HTTP2Url]) -> E:
    ...
      "--d-url", d.url, # an HTTP2Url
    ...
    return E(...)

def main(d: D[HTTP1Url]) -> E:
    return start_e(d) # type error!
#+end_src

The type argument to the =D= class
specifies the type of =d.url=.
(Like Java generics or C++ templates)

A Two Sigma example:
HFMD tickerplant clients can publish over
- msgbox
- mqueue
- jtmqueue
[[./tickerplant.png]]
Types ensure services get the transport they expect

*** Create different envs by passing different args
Service F:
- Can run with or without service G
- Behaves differently if service G is provided
Service G:
- Just some random normal other service
[[./example3.png]]

#+begin_src python
def start_f(g: Optional[G]) -> F:
    ...
    if g:
       ... "--g-url", g.url ...
    else:
       pass
    ...

def environment_one() -> None:
    g = ...
    f = start_f(g)
    ...

def environment_two() -> None:
    f = start_f(None)
    ...
#+end_src

We can use =environment_one= or =environment_two=,
each where appropriate.
(See http://catern.com/config.html)

In TSS Integration,
- production/tests/benchmarking
- TSS/TSI
- equities/futures/options
All build different environments,
out of the same components (functions and types).

*** Interact with the system using the REPL/debugger
A minor nice feature...

We do this frequently when debugging a system,
or manipulating it in an ad-hoc way.

#+begin_src python
>> i = start_i(...)
<I object at 0x7fb3a45a4290>
>> j = start_j(i, ...)
<J object at 0x7fb3a45a4490>
>> j.url
"https://example.com"
#+end_src

So that's how TSS Integration provides
*the ability to run the trading system*.

** In-depth example of a test with TSS Integration

TPS: Two sigma Position Service.

- Receives orders from the outside world over TCP
- Validates and possibly rejects those orders
- Updates another service, =posdelta=, with fills
- Stores data in a SQLite database
[[./tps.png]]

Why TPS?

- The subsystem required to support TPS is small.
- TPS is run by TSS Integration in production.

Our goal:
Put the principles we just discussed into practice

Pretend:
- We're writing the first tests for TPS
  (Normally we'd use the existing =test_tps.py=)
- But we've already written TPS types and functions
- Now let's set up an environment with TPS!

We start with a =TrioTestCase=
(an async-enabled =unittest.TestCase=)

We won't show anything async in this example,
so just ignore the =async= and =await= keywords.
#+begin_src python
class TestTPS(TrioTestCase):
    async def asyncSetUp(self) -> None:
        self.tps = await start_tps(...)

    async def test(self) -> None:
        self.assertTrue("Do test stuff")
#+end_src

We'll start up TPS by calling =start_tps=,
and perform the actual test in =test=.

#+begin_src python
async def start_tps(
  nursery: trio.Nursery,
  thread: rsyscall.Thread,
  listening_sock: FileDescriptor,
  database: integration.tps.Database,
  posdelta: Posdelta,
) -> TPS:
  ...
#+end_src
[[./tps.png]]

#+begin_src python
  nursery: trio.Nursery,
#+end_src

- Starts and detects failures in background tasks
- self.nursery (from TrioTestCase) is a trio.Nursery
  which fails the test if any background task fails

#+begin_src python
    async def asyncSetUp(self) -> None:
        self.tps = await start_tps(
            self.nursery,
            ...,
        )
#+end_src

For more info on trio see:
https://trio.readthedocs.io/en/stable/tutorial.html

#+begin_src python
  thread: rsyscall.Thread,
#+end_src

- Lets us run things on a remote host
- We'll use =local_thread= to just run locally

#+begin_src python
from rsyscall import local_thread

        self.thread = local_thread
        self.tps = await start_tps(
            ...,
            self.thread,
            ...,
        )
#+end_src

For more info on rsyscall see:
https://github.com/catern/rsyscall

#+begin_src python
  listening_sock: FileDescriptor,
#+end_src

- The first TPS-specific argument
- Used by TPS to listen for incoming TCP connections
- Standard Unix socket programming

#+begin_src python
        # make a TCP socket
        sock = await self.thread.socket(
            AF.INET, SOCK.STREAM)
        # bind it to a random port on localhost
        addr = SockaddrIn(0, "127.0.0.1")
        await sock.bind(await self.thread.ptr(addr))
        # and start listening
        await sock.listen(1024)
        self.tps = await start_tps(
            ...,
            sock,
            ...,
        )
#+end_src

#+begin_src python
  database: integration.tps.Database,
#+end_src

- Used by TPS as a backend and persistence mechanism
- =Database.make= creates the DB with the TPS schema
- =make_location= returns a temporary directory,
  for databases and any other state

#+begin_src python
        self.location = make_location()
        self.tps = await start_tps(
            ...,
            # Do it on localhost with self.thread
            await Database.make(
                self.thread, self.location/"tps.db"),
            ...,
        )
#+end_src

#+begin_src python
  posdelta: Posdelta,
#+end_src

- Another service; it distributes position updates

#+begin_src python
async def start_posdelta(
    nursery: trio.Nursery, thread: rsyscall.Thread,
    workdir: Path,
    ..., # some optional arguments, irrelevant here
) -> Posdelta:
#+end_src

- Use the same =trio.Nursery=, =rsyscall.Thread=
- =workdir= is a private directory to store state
- Make =workdir= under the dir from =make_location=

#+begin_src python
        self.tps = await start_tps(
            ...,
            await start_posdelta(
                self.nursery, self.thread,
                (self.location/"posdelta").mkdir()),
            ...,
        )
#+end_src

That's everything!

#+begin_src python
class TestTPS(TrioTestCase):
    async def asyncSetUp(self) -> None:
        self.thread = local_thread
        sock = await self.thread.socket(
            AF.INET, SOCK.STREAM)
        addr = SockaddrIn(0, "127.0.0.1")
        await sock.bind(await self.thread.ptr(addr))
        await sock.listen(1024)
        self.tps = await start_tps(
            self.nursery, self.thread,
            sock,
            await Database.make(
                self.thread, self.location/"tps.db"),
            await start_posdelta(
                self.nursery, self.thread,
                (self.location/"posdelta").mkdir()),
        )
#+end_src

Now we start up the Python client for TPS.
The TPS object contains the address for TPS.

#+begin_src python
    async def asyncSetUp(self) -> None:
        self.tps = ...
        self.client =
            await integration.tps.Client.connect(
                self.thread, self.tps.sockaddr)
#+end_src

Just send an order and fill, for some instrument

#+begin_src python
    async def test(self) -> None:
        order = await self.client.new_order(
            'buy', 100,
            self.tps.static_data.instruments[0],
            price=Decimal('50.0'))
        await order.fill(100, Decimal('50.0'))
#+end_src

- This is a complete test (for one kind of event)
- The client (as in production) checks invariants
- If they're violated, we'll get an exception
- If TPS errors or crashes, we'll get an exception
- Usually, we'd have more services for more coverage

** Closing remarks and questions

By making it easy to run the system,
we've improved our ability to test.

Summary list of features (for later review):
- type-safe composition and configuration of services, without limits
- safe for prod
- runs anywhere, including pre-push, homeservers, or colo
- requires no special privileges
- doesn't depend on any outside services
- can be used interactively from a REPL or debugger
- optimised process startup to avoid the usual monorepo high per-process startup delays
- distributed execution, can run across multiple hosts
- arbitrary universes, can run services from different universes together
- monitors processes at all times so that any process exits will be detected
- processes can be pinned to CPUs
- doesn't leave stray processes behind
- easy to clean up after, everything goes in a single directory

Areas for future development:
- Support for more services
- Usage by more teams
- More production usage

More significant long-term development:
- Usage outside Trading Engineering
  (Seigniorage project?)

How to get started?

To add your services to TSS Integration,
or to write your own library:

1. Understand your service dependencies;
   this is the hardest step!
2. Write it down as classes and function signatures
3. Implement those functions (relatively easy!)

Would you like to know more? Or get help starting?
- Shortly, ask me questions
- Later, feel free to join #x-tss-integration
- Look at ts/tss/integration/README.org
  https://gitlab.twosigma.com/main/ts.d/tss.d/integration-git/-/blob/master/README.org

Hopefully this talk has shown you
the importance of being able to run your system.

Example: trio and rsyscall and remote execution
#+begin_src python
async def start_fooserv(
    nursery: trio.Nursery,
    thread: rsyscall.Thread,
    workdir: Path,
) -> Fooserv:
    command = ts_fooserv.get_c_binary("fooserv").args(
        "--verbose", "--do-stuff-fast",
    )
    child_thread = await thread.clone()
    await child_thread.chdir(workdir)
    child_process = await child.exec(command)
    nursery.start_soon(child_process.check)
    return Fooserv()
#+end_src

