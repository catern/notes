expecting pushback on this kind of presentation
* feedback
** was maybe a little long
   I took 37 minutes and was almost done

   should try and shorten
** they don't like "There's no common service framework"
   "cuz there is one, just not in TE"

   Leah figures there's some reason I'm not using Kubernetes, that's fine

   but they want to make sure they're giving the right guidance for people

   okay, I won't mislead them too much
** the fact that it's used in production as well
   maybe include a concrete example in that?
*** now we've set up everything,
    we could run this in prod,
    or we could run a test in this
** leah wasn't clear that the examples (of start_a etc) are not tests
   maybe should clarify that...
   and more emphasize production usage
** DONE avoid the word daemon
** show impact
   of some complicated thing you can start up using this approach

   a diagram
*** some kind of number or indication of how we use this in prod
** diagrams
   show impact

   show examples
* gracenin feedback
** explanations were clear
** he liked how they went through the start function one by one
*** maybe go through arguments one by one at the beginning?
    not the end
* my todo
** DONE remove the word daemon
** DONE service framework thing
   just changed to say "There's many different kinds of services"
** DONE diagrams
*** put a nice diagram of some complex system we start up
    what would be really nice is to automatically generate the diagram, sigh.

    hmm let's try pycallgraph I guess

    oh!! no!!!

    all I have to do is,
    render the AST!

    just parse the AST of an environment function,

    name each expression,

    and render the graph of the dependencies of the expressions!

    I guess variable names are the names for expressions;

    other expressions... I'll just nest inside?

    but I really do need ssa form hmm

    okay... what if I just evaluate it?

    then I get a full expression,
    with tags...

    and... I can just turn that nested object,
    into a graph. ez.

    oh hey this is really the same thing as that earlier, turn a test into text thing.

    i need to do some tagless final style evaluation of the setup function, kinda thing.

    okay so...
    i'll have some things prepped ahead of time, like uh,
    make_location.

    and then I'll just... run the function in that environment?

    i'll have a getattr implemented to handle any not-explicitly-handled functions/variables
    which will return just Node(stringname)

    and Node will implement __call__ and return some kind of FunctionCall(fname, args)

    then I'll end up with some expressions at the end;
    which will be in fields on self, I guess,
    and I guess will be partially labeled with names.

    and I'll just print that big expression?
    (annotated with names somehow)
    (and somehow finding the largest expression - maybe just print all of them and dedup

    okay and I'll put this in rsyscall
**** keep notes
Or maybe when I make a function call... I just print an arrow? A bunch of arrows, rather?

I create a node, of course... I guess...

Well... I suppose I don't want to create nodes for functions themselves...

So at a function call, I make a node for the call, and make a node for each arg.
And I add arrows to each arg.

But wait, then we're duplicating nodes, since when that function result is used later we'll add more nodes.... Maybe?

Right so I render a function call by rendering each argument - 
which may already have been rendered in which case it's a node name,
or it might be a python value in which case I need to render it anew.

And what I return from a function call is the node name that will be in the graph. Nice.

And then I can attach the fields on self as identifiers for the nodes in the graph. Perfect.

Right okay so we have two types... Symbol, which is just some symbol, and which supports function application.
And Node, which is something that has been rendered in the graph.

And of course there's every other python type too, which we might encounter.  
**** just build the graph directly
okay so I'll just build the graph directly, with Symbols and Nodes

hmm what if I have two places which render the same Symbol?
purr-haps I should just render it as a Node immediately,
then...

blah okay or, better yet,
I'll just have a Symbol.render() which lazily renders the Symbol,
and stores the Node inside the Symbol.

and yeah, Symbol has __call__ and Node does not

ok two places rendering the same symbol are fine,
we'll just render it twice.

i mean, in practice I don't think this will be an issue, so.
*** more diagrams
    these are important for monday, I guess

    yeah I can put the diagram up on the side I guess

    diagrams for each of the type examples would be good

    or maybe, just for the (B, C) -> A example,
    yeah, in the exaplanation of the problem
** DONE put docstrings on the start_a example functions!
** TODO maybe revamp?
   to remove the "it's not testing" part?
* boopy feedback
** don't say it's not testing
   that's kinda pointless and distracting

   instead say what it is.

   positive not negative.
** maybe just go ahead and say what it is up front?
   (boopy: say it three times)

   along with the diagram that gracenin suggested,
   a diagram showing how we set up the system
* talk to highway feedback
** have a better stock answer to how this interacts with prod
   and how this is reconciled with prod

   one thing to say: "this is more accurate than prod"
** someone asked about how to prevent starting services multiple times
** DONE have a supplementary example of distributed execution
   after my last slide
** DONE elina: what does self-contained mean?
   she maybe thought it meant bp5 interaction?

   but I guess I should clarify that it means, like, no talking to celfs or golden core, etc.

   no network services

   I'll just delete that "self-contained" word

   that seems like a full fix
* questions
** 
to use this, how much uptake do I need from the teams I depend on
** 
i don't think i needed to know all 7 parameters
** i was getting lost in the in-depth examples
** i loved that you could go back and forth from the examples
** onboarding
*** maybe be a little more concrete about path to achieve this
    how did my team achieve this?

    how can another team achieve this?

    the question-asker mentioned FTEs and things
** more pictures
** make bullet points more short
   not long sentences
** taz
*** 
what's it like in prod
*** what does the environment
*** why is the environment these parameters
*** make it clear that start_tps is completely specific to TPS
   the arguments are not generalized

   each start function has its own argument
* my to do list
** DONE kill off several of the start_tps arguments
   this should be fine.

   hjmmmmmmmmm

   ok so we clearly need nursery, thread, posdelta, listening sock, static data

   we can replace database and publishing iqueue with a single arg maybe somehow...
   the workdir...
   but it's annoying that we have to... probe to see if there's already data in the workdir.

   we want to be... a little more explicit?

   well, in the wrapper, we... copy the workdir to a new place.
   and then pass it in...
   right now we don't have to probe in start_tps to see if the iqueue and database already exist
   we just know that they do. hmmmm

   okay what about... like...
   we pass workdir: Union[Path, State]

   and if it's a path we create a state,
   and if it's a state we just use that.

   but that's bad, urgh, we'd prefer to just... make the State explicitly outside and pass it in, then...

   what if we connect the iqueue to posdelta externally?
   oh but it needs to read posdelta too, so we aren't avoiding an argument then.

   ok so what we're considering here, is like,
   state which is private to the daemon/object,
   and which is initialized by the daemon/object.

   ehhhh let's just skip the last two arguments, it's fine...

   yeah I mean I guess an opaque State object might be helpful...

   it would change two arguments into one...

   and would allow us to ignore the "internal details" of the dependency on these kinds of state...

   but it's not super desired here because it makes the example less approachable and a little more abstract.

   ok we'll just delete two arguments,
   and keep in mind "State" for the future.
** DONE further shorten sentences I guess
   eh I think it's fine?
** DONE add some pictures
   I guess it can't hurt

   ok I add the logo...

   people want a diagram and they also talk about showing IPC...
*** DONE diagrams for each of the philosophical examples
    okay I like the digrams I have now, nice
*** bar chart of tss/integration vs egregression line counts
    eh I don't really need this
*** TODO inane pictures and memes and things
    yes, I can make the talk more funny this way

    ok we add the mitts and the hi-hat, need to find another way to make a joke hmm...
** DONE deep diagram and/or showing IPC
   ok so why don't I want to show this?
   because the IPC is irrelevant...

   boopy says it could be interesting...

   it might be that people are not clear on, like, how the IPC works
   how do the things get connected??

   so... maybe I could show like...
   what? I'm just not sure

   maybe I should show what the TPS object contains?
   yeah, I'll say that it has the URL of TPS inside it

   okay is that... enough?
   should we, like, show a TPS diagram that is being iteratively built up?
   that would be annoying...
   but could be good...

   well... we'd want to have the full diagram on-screen...

   yeah okay so let's just make a diagram for each dependency in the example, sure.

   and also diagrams for the philosophical examples (worthlessly but whatever)

   no ugh I don't want diagrams for the test examples

   aha okay i put the diagrams up and actually I think it's fine and good
   and I think I'm sufficiently exploring IPC now

   so we'll punt on deep diagram investigation
** DONE explicitly say that TPS has a URL inside it, and we use HTTP to connect to it
   So that's clear... and that might satisfy the desire for talking about IPC
** DONE consider adding more history about how we got here
   and how someone else could get here too

   so I think this is the major thing missing

   we could add this around the onboarding section...

   ok so what do I want to say?

   I don't really think about the organizational stuff...
   but I guess that might be interesting for people.
   I mean, the *truth* is that I just worked on it endlessly myself

   hmMmm
   I invested way more into it than others would
   and that's how we got here.

   well, others contributed as well, especially today,
   but the question is how did we bootstrap to making that viable?
   
   I guess I could say, before we had a set of tests, whatever,
   and we reduced line counts cool, see graph of cloc
*** my advice
    so as a project we'd go one service at a time

    each time we needed some new feature we'd expand integration testing to cover it

    keep in mind you aren't going to break this down to individually trivial parts;
    onboarding a given service might be trivial,
    or it might require a deep understanding
    and require dealing with other dependencies you didn't even know about.

    so you need to be able to take it seriously as a goal, not just a side effect,
    and budget for that possible difficulty.
    if a given service doesn't end up being that difficult,
    you can put that surplus time into polishing the service implementation
    and its interaction with other services.

    i'd say a budget of 1-2 weeks of FTE time per service,
    which includes the development of basic tests for that service.
    that includes the wide variance between trivial services,
    which will take a day or less to understand their dependencies and document them in the code,
    and really difficult services which might take a lot of time.

    for us,
    we're at the point where every new service we add,
    we know we'll use a lot in the future,
    and we know roughly how we'll use it.
    so it's not really worth accruing tech debt for us.
    it's cheaper to do it right up front instead of taking shortcuts.

    of course, it's different if you're new to this and you're not sure if you'll really stick to it.

    anyway so that's our story:

    we added incrementally with each new feature developed,
    both features purely internal to MITS
    and features which services from other teams.

    gradually we accumulated a wide range of support.

    we generally avoided quick easy implementations,
    and instead took the time to do it right,
    and properly integrate with the rest of the system.

    this was because even early on we knew that this system was valuable,
    from how easy it made many things that had previously been difficult,
    like running one-off copies of the system for regulatory incidents,
    or from radically reducing our maintenance burden relative to our old regression tests,
    which were much more heavily based on mocking,
    or when it caught serious bugs before we hit production.
*** so
    process for exansions

    usually we've expanded at points where there is some new feature that requires cross-team integration,
    or changes some cross-team service boundary,
    where at least one of the teams is already in tss/integration.
    after 3 years that leaves us at our current state.

    those are areas which are generally high risk and poorly tested,
    so an investment in testing makes a lot of sense.

    we add support for the side of the boundary which is not in tss/integration.
    this means adding support for one or more new services.

    what does that look like?
    generally, the main difficulty is getting a thorough understanding of the dependencies of the services.
    once the dependencies are understood,
    they can be encoded with functions and classes in ts/tss/integration.

    we usually take the time to do this right, rather than quickly hack it together;
    even in the early days, we already found TSS Integration to be very useful,
    and we knew it would be worthwhile to invest in it properly.
*** in history section
    How does development work?

    Two ways:
    - On any cross-team change, we'll test it in ts/tss/integration,
    expanding ts/tss/integration to cover more services if necessary.
    - Individual teams periodically improve support/testing for their own services.
** DONE REALLY add remote example
   Xu wondered if when running remote processes we still get the same monitoring abilities
** DONE maybe show IPC thing - Xu
   hmm is this the same request as the other guys?
   where they want me to zoom in and show the IPC flow between services

   ok I added sufficient stuff I think
* hi boopy
it went good!

the later part was me helping someone with some other issue -also in TSS integration
(they complimented the talk since they saw it on friday)

but anyway the talk went good!
this one had my boss and one peer in it
they asked questions...
which were a bit revealing that they had inside knowledge
but, it was good
i just don't think i need to take their questions into account as feedback since,
they already know a lot about the system and they can ask questions that have inside knowledge,
that others would not

my boss gave feedback later
** DI and functions
   I think there's some degree to which,
   you have to take into account their popularity

   like functions are very popular

   crazy DI frameworks are also abstractions just like functions, but...
   they have not stood the test of time

   (they are bad)

   also!!! functions are fundamentally used in math and widely known
   they are complex implementation-wise, but they have a clear metaphor and theoretical backing

   DI does not, lol

   nuh uh!
   
   I agree it's a bit of misnomer to call them "functions",
   but the metaphor is good and I think it helps understanding.
   there's no such thing for DI

   I think they would agree if they hate DI frameworks
   if they love DI *frameworks* they would be offended

   yeah just a java thing

   yeah that sucks! true, magic though

   oh there's another place that DI exists though,
   which is the highly pertinent thing to my talk

   service discovery!!!!

   like you just say "hey my service is registering for name foo"
   when you want name foo
   you just ask for name foo
   then you get the *ADDRESS* of the service
   sure, but it's still the same thing!
   symbols and DI are abstracted too!

   DI: I ask for name and type, I get an implementation
   same thing in service discovery

   that's the same thing!
   the DI god object is the same as the service discovery god object!

   not really...
   not fundamentally...

   ok ok fine

   but in frameworks you might not control the DI!

   but fair, you usually configure the DI
   but I still think they have strong correspondences
   (which is the whole point of my talk)

   yeah I guess so...
   I mean...
   oh I'm not dismissing it!!

   I think it's cool - I think it's like dynamic variables kinda
   implicitly picked up stuff from the environment

   lol debatable

   ok ok fair

   I'm comparing it to implicit parameters - which are typed dynamic variables
   which are very close to DI, like, literally very much the same thing...
   well, except more flexible in some ways...
   anyway

   but yeah I think DI is cool!

   such systems are bad :)

   well! I take that back, they aren't bad, we're just not good at writing them yet
   as a field

   yeah yeah yeah
** 
   I feel like I'm that  character Samara in this Harry Potter fanfiction I'm reading
   OC!!!
   she is from Beauxbatons... (sp?)
   this fanfiction has Hermione in Beauxbatons

   anyway

   she is mute and communicates with her magic slate, which she taps with her wand to write words

   yes hers is faster...

   yessssssssssss

   done!

   there are always articles about it, everyone (for small values of everyone) loves it

   brutal
** boopy visits
* suggested intro from boopy
** Introduction
Here's a high level intro
we'll go into each of these in more detail

TSS Intregation is 3 distinct Python Libraries:
*** integration.lib (utilities)  
  - artifact deployment, managing the file system,
    async complexities, etc
*** integration.hfmd, integration.tpe, etc.
  - python functions that bring up elements
    of the 2 Sigma trading system in a convenient,
    legible, and easy to use way.
  - the heart and soul of TSS Integration!
*** integration.tests 
  - portable, comprehensive tests using the
    functions written in the integration.* modules.
* feedback 2 diagram
** DONE bigger text
   ok fine I did it
** put the diagram on the side of the text instead of after it
   that's not something I can easily do, so...
** align it away from the edge
   center the text!

   okaaaaay.

   sooooo

   i can implement this this weekend I guess...

   I'll dig into other emacs presentation modes to see what they do?
   maybe they support this.

   I don't need this anymore since the frame is always full now,
   with windows open
** DONE remove the equals signs
** DONE consider deleting the text when you have the diagrams
   like in the slides when I'm talking about the scenarios for examples

   service D is this, service E is that, etc

   yeah no, I want people to be able to at least *somewhat* understand when reviewing later
** DONE hide the modeline
** DONE add images wherever you have an excuse
   they help a lot

   ok I can do that

   ok I added some more, sigh
** TODO add line count over time graph
   sure, sure

   need to finish this...
** turn on video camera
* boopy feedback
** TODO MARGINS!!!!
   boopy wants me to make the text smaller so I can have bigger margins...
* my own feedback
** TODO try it on laptop
   the issue might be that people are watching it on their laptop,
   and my big screen is getting scaled down.

   i should try it on the laptop to compare...
** DONE need to set up proper website with shorturl
   on my homeserver

   oh actually I think it's fine as it is, just need to update it
** TODO update website with latest talk
** DONE maybe always have two windows open?
   then they won't complain

   yeah okay I can do this, I'm prepped for this
